<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>WinOLS Tuning Simulator (Advanced)</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #333; /* Dark background similar to WinOLS */
      color: #eee; /* Light text for contrast */
      padding: 20px;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      color: #00bfff; /* A bright blue for headings */
      text-align: center;
      margin-bottom: 30px;
    }

    .section {
      background: #444; /* Slightly lighter dark for sections */
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 6px;
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
      width: 90%;
      max-width: 800px;
      border: 1px solid #555;
    }

    .section h3 {
      color: #00bfff;
      margin-top: 0;
      padding-bottom: 10px;
      border-bottom: 1px solid #555;
      margin-bottom: 20px;
    }

    label {
      margin-right: 10px;
      color: #ccc;
      white-space: nowrap; /* Prevent line breaks */
    }

    select, input[type=number], input.hex, button, input[type=file] {
      background: #555;
      color: #eee;
      border: 1px solid #666;
      padding: 8px;
      margin: 5px 10px 5px 0;
      border-radius: 4px;
      font-size: 1em;
    }

    select:focus, input:focus, button:focus, input[type=file]:focus {
      outline: none;
      border-color: #00bfff;
      box-shadow: 0 0 5px rgba(0, 191, 255, 0.5);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
      background: #3a3a3a; /* Darker background for table */
    }

    th, td {
      border: 1px solid #555;
      text-align: center;
      padding: 8px;
      color: #eee;
    }

    th {
      background: #4a4a4a;
      color: #00bfff;
    }

    input[type=number] {
      width: 80px; /* Adjust width for better number input visibility */
      text-align: center;
    }

    .hex-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); /* Responsive grid for hex values */
      gap: 8px;
      margin-top: 15px;
      padding: 10px;
      background: #3a3a3a;
      border-radius: 4px;
      border: 1px solid #555;
    }

    input.hex {
      width: 100%; /* Make hex inputs fill their grid cell */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
      text-transform: uppercase; /* Ensure hex values are uppercase */
      font-family: 'Consolas', 'Monaco', monospace; /* Monospace font for hex values */
    }

    button {
      background: #00bfff; /* Bright blue for the button */
      color: #fff;
      border: none;
      padding: 12px 25px;
      cursor: pointer;
      font-size: 1.1em;
      transition: background 0.3s ease, transform 0.2s ease;
      margin-top: 10px;
      display: block; /* Make button full width in its container */
      width: fit-content; /* Adjust to content width */
      margin-left: auto; /* Center button */
      margin-right: auto; /* Center button */
    }

    button:hover {
      background: #009acd;
      transform: translateY(-2px);
    }

    #resultArea, #messageArea {
      margin-top: 20px;
      padding: 15px;
      background: #3a3a3a;
      border: 1px solid #00bfff;
      border-radius: 4px;
      color: #aaffaa; /* Greenish color for success message */
      text-align: center;
      font-size: 1.1em;
    }
    #messageArea.error {
        color: #ffaaaa;
        border-color: #ff0000;
    }

    .button-group {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
    }

    #graphCanvas {
        width: 100%;
        height: 250px;
        background: #2a2a2a;
        border: 1px solid #555;
        border-radius: 4px;
        margin-top: 15px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <h1>üîß WinOLS ECU Tuning Simulator (Advanced)</h1>

  <div class="section">
    <h3>üìÇ File Operations</h3>
    <div>
      <label for="fileInput">Load ECU File (.bin/.hex):</label>
      <input type="file" id="fileInput" accept=".bin, .hex">
      <button onclick="simulateFileLoad()">Simulate Load</button>
      <button onclick="simulateFileSave()">Simulate Save</button>
    </div>
    <div id="messageArea"></div>
  </div>

  <div class="section">
    <h3>‚öôÔ∏è Vehicle & Model Selection</h3>
    <div>
      <label for="carBrand">Brand:</label>
      <select id="carBrand">
        <option>Mazda</option>
        <option>Toyota</option>
        <option>Honda</option>
        <option>Isuzu</option>
      </select>

      <label for="carModel">Model:</label>
      <select id="carModel">
        <option value="mazda2">Mazda 2 Skyactiv</option>
        <option value="hilux">Hilux Revo</option>
        <option value="civic">Civic Turbo</option>
        <option value="dmax">D-Max Blue Power</option>
      </select>
    </div>
  </div>

  <div class="section">
    <h3>üó∫Ô∏è Map Selection & View Mode</h3>
    <div>
      <label for="mapType">Select Map for Tuning:</label>
      <select id="mapType">
        </select>
    </div>
    <div style="margin-top: 15px;">
      <label for="viewMode">Display Mode:</label>
      <select id="viewMode">
        <option value="text">Text</option>
        <option value="2d">2D Graph</option>
        <option value="3d">3D Graph (Simulated)</option>
      </select>
    </div>
    <canvas id="graphCanvas" style="display: none;"></canvas>
  </div>

  <div class="section">
    <h3>üìà Map Tuning Area</h3>
    <table id="tuningTable">
      <thead>
        <tr><th>RPM</th><th>Load (%)</th><th>Value</th></tr>
      </thead>
      <tbody>
        </tbody>
    </table>
  </div>

  <div class="section">
    <h3>üî¢ HEX Viewer</h3>
    <div class="hex-grid" id="hexGrid">
      </div>
  </div>

  <div class="section">
    <div class="button-group">
        <button onclick="confirmTuning()">‚úÖ Confirm Tuning</button>
        <button onclick="compareMaps()">üìä Compare Maps</button>
        <button onclick="calculateChecksum()">‚ûï Calc Checksum</button>
        <button onclick="undoLastChange()">‚Ü©Ô∏è Undo</button>
    </div>
    <div id="resultArea"></div>
  </div>

  <script>
    // --- Global State ---
    let currentECUFile = null; // Simulates the loaded ECU file content (as a conceptual array of hex bytes)
    let currentMapData = null; // Stores the data of the currently selected map
    let currentMapDefinition = null; // Stores definition (factor, offset, structure) of current map
    let history = []; // For Undo functionality
    let historyPointer = -1;

    // --- Data Definitions (Enhanced for more realistic maps) ---
    // In a real scenario, these definitions would come from an external database or file.
    const ecuDefinitions = {
      mazda2: {
        iq_limit: {
          name: "IQ Limit (mg/stroke)",
          address: 0x1000, // Simulated start address in the ECU file
          size: 4 * 1, // 4 data points, 1 byte per value (simulated)
          type: "8-bit unsigned",
          factor: 0.01,
          offset: 0,
          axes: { x: "RPM", y: "Load" },
          defaultData: [
            { rpm: 1000, load: 30, hexValue: "78" }, // 120 * 0.01 = 1.2 mg
            { rpm: 2000, load: 60, hexValue: "D2" }, // 210 * 0.01 = 2.1 mg
            { rpm: 3000, load: 90, hexValue: "14A" }, // 330 * 0.01 = 3.3 mg (should be 2 bytes for this value)
            { rpm: 4000, load: 100, hexValue: "190" }  // 400 * 0.01 = 4.0 mg (should be 2 bytes for this value)
          ]
        },
        torque_map: {
          name: "Torque Map (Nm)",
          address: 0x2000,
          size: 3 * 2, // 3 data points, 2 bytes per value (simulated)
          type: "16-bit unsigned",
          factor: 0.5,
          offset: 0,
          axes: { x: "RPM", y: "TPS" },
          defaultData: [
            { rpm: 1500, tps: 40, hexValue: "00C8" }, // 200 dec. 200 * 0.5 = 100 Nm
            { rpm: 2500, tps: 70, hexValue: "012C" }, // 300 dec. 300 * 0.5 = 150 Nm
            { rpm: 3500, tps: 95, hexValue: "01F4" }  // 500 dec. 500 * 0.5 = 250 Nm
          ]
        },
        dtc_switch: {
            name: "DTC Switch",
            address: 0x3000,
            size: 8, // 8 bytes (simulated)
            type: "8-bit raw",
            factor: 1, offset: 0,
            axes: { x: null, y: null },
            defaultData: [
                { id: "P0420", hexValue: "01" }, // On/Off switch
                { id: "P0171", hexValue: "01" },
                { id: "P0300", hexValue: "00" },
                { id: "P0440", hexValue: "01" },
                { id: "P0455", hexValue: "00" },
                { id: "P0460", hexValue: "01" },
                { id: "P0470", hexValue: "01" },
                { id: "P0480", hexValue: "00" },
            ]
        }
        // ... add more map definitions for other vehicles and types
      },
      hilux: {
          // Placeholder for Hilux maps
      }
    };

    // --- DOM Elements ---
    const carModelSelect = document.getElementById("carModel");
    const mapTypeSelect = document.getElementById("mapType");
    const tuningTableBody = document.querySelector("#tuningTable tbody");
    const hexGrid = document.getElementById("hexGrid");
    const resultArea = document.getElementById("resultArea");
    const messageArea = document.getElementById("messageArea");
    const viewModeSelect = document.getElementById("viewMode");
    const graphCanvas = document.getElementById("graphCanvas");
    const graphCtx = graphCanvas.getContext('2d');
    let chartInstance; // To hold our Chart.js instance

    // --- Utility Functions ---

    // Converts a decimal number to a hex string with specific length
    function decToHex(d, padLength = 2) {
        let hex = Number(d).toString(16).toUpperCase();
        return hex.padStart(padLength, '0');
    }

    // Converts a hex string to a decimal number
    function hexToDec(h) {
        return parseInt(h, 16);
    }

    // Displays messages to the user
    function showMessage(msg, isError = false) {
        messageArea.textContent = msg;
        messageArea.className = isError ? "error" : "";
        clearTimeout(messageArea.timer);
        messageArea.timer = setTimeout(() => {
            messageArea.textContent = '';
            messageArea.className = '';
        }, 5000);
    }

    // --- Core Logic ---

    // Populates map options based on selected car model
    function populateMapOptions() {
        const selectedModel = carModelSelect.value;
        const mapsForModel = ecuDefinitions[selectedModel];
        mapTypeSelect.innerHTML = ''; // Clear existing options

        if (mapsForModel) {
            for (const mapKey in mapsForModel) {
                const option = document.createElement("option");
                option.value = mapKey;
                option.textContent = mapsForModel[mapKey].name;
                mapTypeSelect.appendChild(option);
            }
        } else {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No maps available";
            mapTypeSelect.appendChild(option);
        }
        loadMapData(); // Load map data for the first option
    }

    // Loads and displays the selected map data
    function loadMapData() {
        const selectedModel = carModelSelect.value;
        const selectedMapType = mapTypeSelect.value;

        if (!selectedMapType || !ecuDefinitions[selectedModel] || !ecuDefinitions[selectedModel][selectedMapType]) {
            tuningTableBody.innerHTML = '<tr><td colspan="3">No data available for this map.</td></tr>';
            hexGrid.innerHTML = '';
            currentMapData = null;
            currentMapDefinition = null;
            renderGraph(); // Clear graph if no map
            return;
        }

        currentMapDefinition = ecuDefinitions[selectedModel][selectedMapType];
        // Deep copy the default data to currentMapData for modification
        currentMapData = JSON.parse(JSON.stringify(currentMapDefinition.defaultData));

        renderTuningTable();
        renderHexGrid();
        renderGraph();
        addToHistory(); // Save initial state to history
    }

    // Renders the table view of the map
    function renderTuningTable() {
      tuningTableBody.innerHTML = '';
      if (!currentMapData || currentMapData.length === 0) {
          tuningTableBody.innerHTML = '<tr><td colspan="3">No map data to display.</td></tr>';
          return;
      }

      const isDTC = currentMapDefinition.name.includes("DTC Switch");

      currentMapData.forEach((row, index) => {
        let displayValue;
        if (isDTC) {
            displayValue = row.hexValue === "01" ? "Enabled" : "Disabled";
        } else {
            displayValue = (hexToDec(row.hexValue) * currentMapDefinition.factor + currentMapDefinition.offset).toFixed(currentMapDefinition.factor < 1 ? 2 : 0);
        }

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.rpm || row.id || '-'}</td>
          <td>${row.load || row.tps || '-'}</td>
          <td>
            ${isDTC ? `
                <select class="map-value-input" data-index="${index}">
                    <option value="01" ${row.hexValue === "01" ? 'selected' : ''}>Enabled</option>
                    <option value="00" ${row.hexValue === "00" ? 'selected' : ''}>Disabled</option>
                </select>
            ` : `
                <input type="number" class="map-value-input" data-index="${index}" value="${displayValue}">
            `}
          </td>
        `;
        tuningTableBody.appendChild(tr);
      });

      document.querySelectorAll(".map-value-input").forEach(input => {
        input.addEventListener("change", updateFromMapTable);
      });
    }

    // Renders the HEX Viewer grid
    function renderHexGrid() {
      hexGrid.innerHTML = '';
      if (!currentMapData || currentMapData.length === 0) {
          hexGrid.innerHTML = 'No HEX data to display.';
          return;
      }

      let maxLength = 2; // Default for 8-bit
      if (currentMapDefinition.type === "16-bit unsigned") {
          maxLength = 4;
      }

      currentMapData.forEach((row, index) => {
        const input = document.createElement("input");
        input.type = "text";
        input.className = "hex";
        input.maxLength = maxLength;
        input.value = row.hexValue;
        input.setAttribute("data-index", index);
        input.addEventListener("input", updateFromHexGrid);
        hexGrid.appendChild(input);
      });
    }

    // Updates map data and HEX viewer from table input
    function updateFromMapTable(event) {
      const index = parseInt(event.target.dataset.index);
      let newValue = event.target.value; // Can be number or string ('Enabled'/'Disabled')

      addToHistory(); // Save current state before modification

      let hexEquivalent;
      if (currentMapDefinition.name.includes("DTC Switch")) {
          hexEquivalent = newValue; // '01' or '00' directly
      } else {
          newValue = parseFloat(newValue);
          if (isNaN(newValue)) return;
          hexEquivalent = Math.round((newValue - currentMapDefinition.offset) / currentMapDefinition.factor);
          // Clamp values to prevent overflow for 8-bit or 16-bit
          if (currentMapDefinition.type === "8-bit unsigned") {
              hexEquivalent = Math.max(0, Math.min(hexEquivalent, 255));
          } else if (currentMapDefinition.type === "16-bit unsigned") {
              hexEquivalent = Math.max(0, Math.min(hexEquivalent, 65535));
          }
      }

      const hexString = decToHex(hexEquivalent, currentMapDefinition.type === "16-bit unsigned" ? 4 : 2);
      currentMapData[index].hexValue = hexString;

      const hexInput = hexGrid.querySelector(`input[data-index="${index}"]`);
      if (hexInput) {
        hexInput.value = hexString;
      }
      renderGraph(); // Update graph after change
      resultArea.innerHTML = ''; // Clear old result messages
    }

    // Updates map data and table from HEX viewer input
    function updateFromHexGrid(event) {
      const index = parseInt(event.target.dataset.index);
      let newHexValue = event.target.value.toUpperCase();

      if (!/^[0-9A-F]*$/.test(newHexValue) || (currentMapDefinition.type === "8-bit unsigned" && newHexValue.length > 2) || (currentMapDefinition.type === "16-bit unsigned" && newHexValue.length > 4)) {
        event.target.value = currentMapData[index].hexValue; // Revert if invalid
        showMessage("Invalid HEX input.", true);
        return;
      }

      // Pad with leading zeros if not full length
      if (currentMapDefinition.type === "8-bit unsigned" && newHexValue.length === 1) newHexValue = '0' + newHexValue;
      if (currentMapDefinition.type === "16-bit unsigned" && newHexValue.length < 4) newHexValue = newHexValue.padStart(4, '0');

      addToHistory(); // Save current state before modification

      currentMapData[index].hexValue = newHexValue;

      const mapInput = tuningTableBody.querySelector(`[data-index="${index}"]`);
      if (mapInput) {
          if (currentMapDefinition.name.includes("DTC Switch")) {
              mapInput.value = newHexValue; // '01' or '00'
          } else {
              const actualValue = (hexToDec(newHexValue) * currentMapDefinition.factor + currentMapDefinition.offset).toFixed(currentMapDefinition.factor < 1 ? 2 : 0);
              mapInput.value = actualValue;
          }
      }
      renderGraph(); // Update graph after change
      resultArea.innerHTML = ''; // Clear old result messages
    }

    // --- Graphing (2D Simulation with Chart.js) ---
    function renderGraph() {
        const viewMode = viewModeSelect.value;
        if (chartInstance) {
            chartInstance.destroy(); // Destroy previous chart instance
        }

        if (viewMode === '2d' && currentMapData && currentMapDefinition && !currentMapDefinition.name.includes("DTC Switch")) {
            graphCanvas.style.display = 'block';
            const labels = currentMapData.map(d => d.rpm || d.load || d.tps); // Use appropriate axis label
            const dataValues = currentMapData.map(d => (hexToDec(d.hexValue) * currentMapDefinition.factor + currentMapDefinition.offset));

            chartInstance = new Chart(graphCtx, {
                type: 'line', // Line chart for 2D map
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${currentMapDefinition.name} Values`,
                        data: dataValues,
                        borderColor: '#00bfff',
                        backgroundColor: 'rgba(0, 191, 255, 0.2)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3 // Make the line slightly curved
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: currentMapDefinition.axes.x || (currentMapDefinition.axes.y ? 'Load/TPS' : 'Index'),
                                color: '#ccc'
                            },
                            ticks: { color: '#eee' },
                            grid: { color: '#555' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: currentMapDefinition.name,
                                color: '#ccc'
                            },
                            ticks: { color: '#eee' },
                            grid: { color: '#555' }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#eee'
                            }
                        }
                    }
                }
            });
        } else {
            graphCanvas.style.display = 'none'; // Hide canvas if not 2D mode or not applicable
            if (viewMode === '3d') {
                showMessage("3D Graph visualization is highly complex and requires advanced libraries (e.g., Three.js) and data structures.", false);
            } else if (currentMapDefinition && currentMapDefinition.name.includes("DTC Switch")) {
                showMessage("2D Graph is not applicable for DTC Switch map.", false);
            }
        }
    }

    // --- File Operations Simulation ---
    function simulateFileLoad() {
        const fileInput = document.getElementById("fileInput");
        if (fileInput.files.length === 0) {
            showMessage("Please select a file to simulate loading.", true);
            return;
        }

        const file = fileInput.files[0];
        // In a real app, you would read the binary content of the file here.
        // For simulation, we'll just acknowledge the file and "load" a dummy ECU content.
        showMessage(`Simulating loading of "${file.name}"... This is where the actual binary parsing would happen.`);
        
        // Simulate a dummy ECU file content (as an array of bytes/hex strings)
        // In reality, this would be parsing the actual .bin or .hex file
        currentECUFile = Array(0x4000).fill('00'); // Simulate a 16KB ECU file filled with '00'
        // And then populate specific map regions with our default data
        // This is a very simplified simulation of how data would be read from a file.
        for (const modelKey in ecuDefinitions) {
            for (const mapKey in ecuDefinitions[modelKey]) {
                const mapDef = ecuDefinitions[modelKey][mapKey];
                let currentAddress = mapDef.address;
                mapDef.defaultData.forEach(item => {
                    const hexBytes = item.hexValue;
                    for (let i = 0; i < hexBytes.length; i += 2) {
                        if (currentAddress < currentECUFile.length) {
                             currentECUFile[currentAddress++] = hexBytes.substring(i, i + 2);
                        }
                    }
                });
            }
        }

        // Once file is "loaded", we can select a default map
        populateMapOptions(); // This will also call loadMapData()
    }

    function simulateFileSave() {
        if (!currentECUFile) {
            showMessage("No ECU file loaded to save.", true);
            return;
        }

        // In a real app, you would compile currentMapData back into the currentECUFile
        // then trigger a download of the modified binary file.
        // This would involve converting all modified HEX values back into a binary array.

        // For simulation, just show a message.
        showMessage("Simulating saving of modified ECU file. This is where the file would be compiled and downloaded.");
    }

    // --- Tuning Functions ---

    function confirmTuning() {
      if (!currentMapData) {
          resultArea.innerHTML = "<p style='color: #ffaaaa;'>Please load a map first.</p>";
          return;
      }
      const map = mapTypeSelect.options[mapTypeSelect.selectedIndex].text;
      const mode = viewModeSelect.value;

      // Simulate the impact of tuning based on changes
      let originalTotalValue = 0;
      let modifiedTotalValue = 0;

      // Calculate totals for comparison (for non-DTC maps)
      if (!currentMapDefinition.name.includes("DTC Switch")) {
          ecuDefinitions[carModelSelect.value][mapTypeSelect.value].defaultData.forEach(item => {
              originalTotalValue += hexToDec(item.hexValue);
          });
          currentMapData.forEach(item => {
              modifiedTotalValue += hexToDec(item.hexValue);
          });
      }

      let hpChange = 0;
      let torqueChange = 0;
      let response = "Standard response.";

      const diffRatio = (modifiedTotalValue - originalTotalValue) / originalTotalValue;

      if (mapTypeSelect.value === "iq_limit") {
        hpChange = (diffRatio * 25).toFixed(1); // Simulating up to 25 HP change
        torqueChange = (diffRatio * 30).toFixed(1); // Simulating up to 30% torque change
        response = diffRatio > 0 ? "Significantly improved throttle response and power delivery." : "Softer power delivery for economy.";
      } else if (mapTypeSelect.value === "torque_map") {
        hpChange = (diffRatio * 20).toFixed(1);
        torqueChange = (diffRatio * 35).toFixed(1);
        response = diffRatio > 0 ? "Stronger pull throughout the RPM range." : "Smoother and more linear torque delivery.";
      } else if (mapTypeSelect.value === "dtc_switch") {
          // For DTC switch, check if any DTCs are disabled (value '00')
          const disabledDTCs = currentMapData.filter(d => d.hexValue === "00");
          if (disabledDTCs.length > 0) {
              response = `Warning: ${disabledDTCs.length} DTCs (${disabledDTCs.map(d => d.id).join(', ')}) are currently disabled. Use with caution!`;
              resultArea.style.color = '#ffaa00'; // Orange for warning
          } else {
              response = "All DTCs are enabled as per standard. No issues detected.";
              resultArea.style.color = '#aaffaa'; // Green
          }
          hpChange = "N/A";
          torqueChange = "N/A";
      } else {
          hpChange = (diffRatio * 10).toFixed(1);
          torqueChange = (diffRatio * 10).toFixed(1);
          response = "General performance adjustment.";
      }

      resultArea.innerHTML = `
        <p>‚úÖ Tuning of "${map}" in "${mode}" view mode completed!</p>
        <p>Initial Results: Horsepower change ~${hpChange} HP, Torque change ~${torqueChange} %, ${response}</p>
        <p><em>(‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏π‡∏ô‡∏à‡∏£‡∏¥‡∏á ‡πÅ‡∏ï‡πà‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á)</em></p>
      `;
      resultArea.style.color = '#aaffaa'; // Reset color
    }

    function compareMaps() {
        if (!currentMapData || history.length < 2) {
            showMessage("Load a map and make changes to compare.", true);
            return;
        }

        const originalMapState = history[0]; // Assuming first state is original
        let changes = 0;
        let comparisonDetails = 'Changes detected:<br>';

        currentMapData.forEach((modifiedItem, index) => {
            const originalItem = originalMapState.currentMapData[index];
            if (originalItem && modifiedItem.hexValue !== originalItem.hexValue) {
                changes++;
                comparisonDetails += `Row ${index + 1} (${modifiedItem.rpm || modifiedItem.id}): Original HEX: ${originalItem.hexValue}, Modified HEX: ${modifiedItem.hexValue}<br>`;
            }
        });

        if (changes === 0) {
            showMessage("No changes detected between current map and original state.", false);
        } else {
            resultArea.innerHTML = `
                <p>üìä Map Comparison Complete: Found ${changes} differences.</p>
                <p>${comparisonDetails}</p>
            `;
            resultArea.style.color = '#ffffaa'; // Yellow for comparison
        }
    }

    function calculateChecksum() {
        if (!currentECUFile) {
            showMessage("No ECU file loaded to calculate checksum. Load a file first.", true);
            return;
        }

        // In a real scenario, checksum calculation is highly specific to ECU type.
        // It's usually a complex algorithm (e.g., CRC32, Fletcher-16) applied over specific regions of the binary.
        // For simulation, we'll do a very simple sum of hex values.
        let sum = 0;
        currentECUFile.forEach(hexByte => {
            sum += hexToDec(hexByte);
        });

        const simulatedChecksum = decToHex(sum % 65536, 4); // Sum modulo 65536 (for 2-byte checksum)

        resultArea.innerHTML = `
            <p>‚ûï Simulated Checksum Calculation Complete.</p>
            <p>Calculated Checksum: <strong>0x${simulatedChecksum}</strong></p>
            <p><em>(‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Checksum ‡∏à‡∏£‡∏¥‡∏á‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á‡∏Å‡∏±‡∏ö ECU ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó)</em></p>
        `;
        resultArea.style.color = '#aaffaa';
    }

    // --- Undo/Redo Functionality ---
    function addToHistory() {
        // Remove future states if we're not at the latest point in history
        if (historyPointer < history.length - 1) {
            history = history.slice(0, historyPointer + 1);
        }
        // Save a deep copy of the current state
        history.push({
            currentMapData: JSON.parse(JSON.stringify(currentMapData)),
            currentMapDefinition: JSON.parse(JSON.stringify(currentMapDefinition))
        });
        historyPointer++;
    }

    function undoLastChange() {
        if (historyPointer > 0) {
            historyPointer--;
            const prevState = history[historyPointer];
            currentMapData = JSON.parse(JSON.stringify(prevState.currentMapData));
            currentMapDefinition = JSON.parse(JSON.stringify(prevState.currentMapDefinition));
            renderTuningTable();
            renderHexGrid();
            renderGraph();
            showMessage("Undo successful.", false);
        } else {
            showMessage("No more changes to undo.", true);
        }
    }

    // --- Event Listeners and Initial Load ---
    document.addEventListener("DOMContentLoaded", () => {
      carModelSelect.addEventListener("change", populateMapOptions);
      mapTypeSelect.addEventListener("change", loadMapData); // Reload map when type changes
      viewModeSelect.addEventListener("change", renderGraph); // Render graph when view mode changes
      
      // Initial load: Simulate a file load and populate maps
      simulateFileLoad(); // This will trigger populateMapOptions and loadMapData
    });
  </script>

</body>
</html>
